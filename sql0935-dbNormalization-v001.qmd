---
format: 
  html:
    toc: true
    toc-expand: 3
    toc-depth: 3
    number-sections: true
---

<!-- YR NOTES
The original document was generated by Claude.ai
URL: https://claude.ai/chat/51cc0cc9-d045-4e7e-8ccc-347c55fa45c3
TOPIC: Normalization Examples for Database Course
-->


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(RSQLite)
library(DBI)
library(dplyr)
library(knitr)
library(sqldf)
#library(gt)
```

# <yrChapterNumber>37. </yrChapterNumber> Database Normalization

The same data can be arranged in a database in many different ways. 
This section describes how to intelligently arrange your data in a 
relational database.

**Database normalization** is the process of designing database tables so that 

* they are in good form for manipulating with SQL 
  (this the focus of "1st normal form" - see below)

* there is minimal repetition of data (this is the focus
  of "2nd normal form" and "3rd normal form" - see below)

## Normal Forms

Database normalization is accomplished in several steps. 
There are different "levels" of normalization, each level progressing 
towards a more perfect organization of the data.
Each level is called a "Normal Form". We say that a database is 
"in" a particular normal form when the tables are structured in a way
that conforms to the rules of that normal form. This will all become
much more clear as you progress through the material below.
In a ***fully normalized database*** the only
data that should be repeated are the primary/foreign keys.

The following are the various normal forms. You are not expected to understand
the technical terms in the list below. These will be covered in the material 
that follows this section.

* 1NF (1st Normal Form) - only atomic values in columns, no repeating groups or arrays
* 2NF (2nd Normal Form) - no "partial functional dependencies (pFD)"
* 3NF (3rd Normal Form) - no "transitive functional dependencies (tFD)"

Most database designers aim to have their databases at least in 3rd Normal Form. 
However, the following additional normal forms are used to further "normalize"
a database to deal with special cases.

In this material we will only be covering 1st, 2nd and 3rd normal forms.
The list below is provided in case you want to do your own research.

* Bocye-Codd Normal Form (BCNF) - every determinant (attribute that determines other attributes) must be a candidate key
* 4NF - no multi-valued dependencies
* 5NF - tables cannot be losslessly decomposed into smaller tables
* 6NF - tables must be irreducible, containing no non-trivial join dependencies


## First Normal Form (1NF)

First normal form requires that

* There be only one value in each "cell" of a table.  
  (AKA "all attributes contain only atomic values")
  
* There should NOT be multiple columns for the same type of data  
  (AKA There are no "repeating groups".)

The following tables are ***not*** in 1st normal form (1NF).

* This table contains multiple values in a single cell which 
  violates the rules of 1NF
  
  ```{r}
  #| echo: false
  
  orders = data.frame(orderNum = c("ord100", "ord200"),
                      products = c("3 apples, 2 plums", "5 apples, 3 pears, 10 plums"))
  
  #gt(orders) %>% tab_header(title = "orders")
  kable(orders, caption="orders")
  ```


* This table contains multiple columns for similar types of data.
  This also violates the rules of 1NF.
  
  ```{r}
  #| echo: false
  
  orders = data.frame(orderNum = c("ord100", "ord200"),
                      product1 = c("apples", "apples"),
                      quantity1 = c(3,5),
                      product2 = c("plums", "pears"),
                      quantity2 = c(2,3),
                      product1 = c("NULL", "plums"),
                      quantity3 = c("NULL", 10))
  
  #gt(orders) %>% tab_header(title = "orders")
  kable(orders, caption="orders")
  ```

### Converting the data to 1NF

The following table contains the same data in first normal form:

  ```{r}
  #| echo: false
  
  orders = data.frame(orderNum = c("ord100", "ord100", "ord200", "ord200", "ord200" ),
                      product = c("apples", "plums", "apples", "pears", "plums"),
                      quantity = c(3,2,5,3,10))

  #gt(orders) %>% tab_header(title = "orders")  
  kable(orders, caption="orders")
  ```


## Example - college class offerings 

The data shown below about classes, sections and professors can be arranged
in many different formats. 

### All data in a single table

For example, the following data could be in a single table. 
This makes it very easy for people to read the info.

```{r}
#| echo: false

classOfferings = data.frame(
  className = c("Intro to IDS", "Intro to IDS", "Intro to IDS", "Intro to IDS", "Database Design"),
  classNum = c("IDS1020","IDS1020","IDS1020","IDS1020","IDS2040"),
  credits = c(3,3,3,3,4),
  section = c(231, 241, 331, 341, 133),
  room = c("F201", "F201", "F310", "F310", "F250"),
  professor = c("joe jones","joe jones","sue smith","sue smith","joe jones"),
  office = c("B102", "B102", "B231", "B231", "B102"),
  email = c("joe@abc.edu","joe@abc.edu","sue@abc.edu","sue@abc.edu","joe@abc.edu"),
  tel = c("(212)555-5555","(212)555-5555","(212)999-9999","(212)999-9999","(212)555-5555" )
)


kable(classOfferings, caption = "classOfferings")
```


### "Normalize" tables to reduce duplication of data

If you look closely at the data in the example above, you'll notice that the
details for each professor (i.e. name, office, email, tel) is duplicated 
in multiple rows. This makes it very easy
for people to read the data. However, this is NOT a great way to store 
information in a relational database (keep reading).

Having the same data in more than one place in a database can lead to 
inconsistencies in the data. For example if a database records a person's 
name in more than one place and the person changes their name, then all 
copies of the person's name would need to be updated. If due to some 
miscalculation, some copies of the person's name were updated and some 
weren't updated, the database would be inconsistent. One of the major 
goals of a good database design is to eliminate redundant data. All data, 
other than primary keys and foreign keys, should be recorded in one 
and only one place in the database.


### split professor data into a different table

The data shown above can be reorganized into the following
structure to avoid duplicating each professor's details.
  

```{r}
#| echo: false

offerings = data.frame(
  className = c("Intro to IDS", "Intro to IDS", "Intro to IDS", "Intro to IDS", "Database Design"),
  classNum = c("IDS1020","IDS1020","IDS1020","IDS1020","IDS2040"),
  credits = c(3,3,3,3,4),
  section = c(231, 241, 331, 341, 133),
  room = c("F201", "F201", "F310", "F310", "F250"),
  prof_id = c("P100", "P100", "P200", "P200", "P100")
)

professors = data.frame(
  prof_id = c("P100", "P200"),
  first = c("joe","sue"),
  last = c("jones", "smith"),
  office = c("B102", "B231"),
  email = c("joe@abc.edu","sue@abc.edu"),
  tel = c("(212)555-5555","(212)999-9999")
)


kable(offerings, caption = "offerings")
kable(professors, caption = "professors")
```

#### SQL SELECT to regenerate original "all in one" table

We are able to see the data as it was originally presented by using the 
following SQL query:

```{r}
queryResults = 
  sqldf("
    select className, classNum, credits, section, room, first || ' ' || last as professor, office, email, tel
    from offerings join professors on offerings.prof_id = professors.prof_id
    order by classNum, section
  ")

kable(queryResults, caption = "queryResults")
```

### Split common class info into a different table

The same data can be still further reorganized into the following
structure to avoid duplicating the details for each class:

```{r}
#| echo: false

classes = data.frame(
  classNum = c("IDS1020", "IDS2040"),
  className = c("Intro to IDS", "Database Design"),
  credits = c(3,4)
)

offerings = data.frame(
  crn = c("12100", "12100", "12100", "12100", "14301"),
  classNum = c("IDS1020","IDS1020","IDS1020","IDS1020","IDS2040"),
  section = c(231, 241, 331, 341, 133),
  room = c("F201", "F201", "F310", "F310", "F250"),
  prof_id = c("P100", "P100", "P200", "P200", "P100")
)

professors = data.frame(
  prof_id = c("P100", "P200"),
  first = c("joe","sue"),
  last = c("jones", "smith"),
  office = c("B102", "B231"),
  email = c("joe@abc.edu","sue@abc.edu"),
  tel = c("(212)555-5555","(212)999-9999")
)


kable(classes, caption = "classes", booktabs=TRUE)
kable(offerings, caption = "offerings", booktabs=TRUE)
kable(professors, caption = "professors", booktabs=TRUE)
```

#### SQL SELECT to regenerate original "all in one" table

We are able to see the data as it was originally presented by using the 
following SQL query:

```{r}
queryResults = 
  sqldf("
    select className, classes.classNum, credits, section, room, 
           first || ' ' || last as professor, office, email, tel
    from classes join offerings on classes.classNum = offerings.classNum 
                 join professors on offerings.prof_id = professors.prof_id
    order by classes.classNum, section
  ")

kable(queryResults, caption = "queryResults", booktabs=TRUE)

```


## 2NF and 3NF: Formal rules for how to split a table into multiple tables to avoid duplicated data

The previous section showed an example of how to split a single table into 
multiple tables in order to avoid duplication of data. We didn't give formal
rules, we just used our intuition for how to do so. 

It's usually pretty straight forward to arrange your data correctly to avoid
data duplication. In general think about the the different
types of "entities" that your data describes (e.g. courses, students, professors, etc). 
Then create a different table for each type of entity and relate the tables using PK and FK
columns. However, it's possible to miss obvious issues unless you carefully 
analyze the data. 

This section introduces a formal set of rules for how to split up tables to avoid
data duplication. To this end, we will focus on how to put tables into 
"Second Normal Form (2NF)" and "Third Normal Form (3NF)".
A prerequisite to understanding 2nd and 3rd normal forms is to understand
what a "functional dependency (FD)" is.

### What is a Functional Dependency (FD)

A **functional dependency** describes a relationship between columns (attributes) in a table.

A functional dependency is a relationship between the columns
in a table where the values in one column (or a set of columns) uniquely 
determines the values in another column. If the value in column A 
determines the value in column B (denoted as A → B), 
then for any given value of A, there can only ever be exactly one value 
of B associated with it. 
For example, if StudentID → StudentName, then knowing a specific StudentID 
uniquely identifies the corresponding StudentName.


### Functional Dependency Rules: `X, Y → A, B, C`

A functional dependency rule can be written in the following format 
where A,B,C,D are column names.

A -> B,C,D


- The **left-hand side (LHS)** contains the **determinant(s)** — the column(s) that determine the values of other columns.

- The **right-hand side (RHS)** contains the **dependent** column(s) — the values that are determined.

- Both the left hand side and the right hand side can have any number of columns.

For example a functional dependency can also take a form
similar to:

A,B -> C,D,E

Where the values in columns A and B taken together functionally determine the values of columns C,D and E.

### Example Table: StudentCourse

| StudentID | FirstName | LastName | CourseID | CourseName     | Credits | Grade |
|-----------|-----------|----------|----------|----------------|---------|-------|
| 001       | Alice     | Smith    | C101     | Intro to Math  | 3       | A     |
| 002       | Bob       | Jones    | C101     | Intro to Math  | 3       | B     |
| 001       | Alice     | Smith    | C102     | English 101    | 4       | A-    |


The functional dependencies are:

1. `StudentID → FirstName, LastName`  
   - A student ID uniquely determines the student's name.

2. `CourseID → CourseName, Credits`  
   - A course ID determines the course details.

3. `StudentID, CourseID → Grade`  
  
   - The **composite key** of student and course determines the grade.

## Primary Key (PK), candidate PK, composite PK

We simplified the last functional dependency rule a little
in order to highlight that StudentId and CourseId determine the Grade value. 

However, if you look carefully you should notice that since SudentId determines 
all of the student related details
and CourseId determines all of the Course details, and these are ALL of the 
columns in the table. We can write that as:

  `StudentID, CourseID → FirstName, LastName, CourseName, Credicts, Grade`  
   
Since this functional dependency rule 
includes all of the columns in the table, we say that 
`StudentId, CourseId` is a ***candidate*** **primary key** for the table.
If there would be more than one candidate PK (there isn't in this table) then
one of the candidate PK's would be chosen as THE primary key for the table.

A Primary Key that is the combination of more than one column is known
as a ***composite*** **primary key**.


## New example - to demo 2NF and 3NF

Let's start with a new example. 

This example also involves courses in a college. 
It is similar to the previous example but the data is slightly different.
This new example contains information about students, their courses, grades, and detailed department information. Let's normalize this table step by step.

The table is already in first normal form (see above).

```{r}
# Create the initial non-normalized table
first_normal_form <- data.frame(
  StudentID = c("001", "002", "001", "003", "002"),
  FirstName = c("Alice", "Bob", "Alice", "Carol", "Bob"),
  LastName = c("Smith", "Jones", "Smith", "Davis", "Jones"),
  CourseID = c("C101", "C101", "C102", "C103", "C103"),
  CourseName = c("Intro to Math", "Intro to Math", "English 101", "Calculus I", "Calculus I"),
  Credits = c(3, 3, 4, 4, 4),
  DepartmentID = c("D01", "D01", "D02", "D01", "D01"),
  DepartmentName = c("Mathematics", "Mathematics", "English", "Mathematics", "Mathematics"),
  DepartmentHead = c("Dr. Johnson", "Dr. Johnson", "Dr. Williams", "Dr. Johnson", "Dr. Johnson"),
  DeptPhone = c("(555) 123-4567", "(555) 123-4567", "(555) 987-6543", "(555) 123-4567", "(555) 123-4567"),
  DeptOffice = c("Room A100", "Room A100", "Room B200", "Room A100", "Room A100"),
  Grade = c("A", "B", "A-", "B+", "C+"),
  stringsAsFactors = FALSE
)

# Display the non-normalized table
library(knitr)
kable(first_normal_form, caption = "registration table")
```

### The functional dependencies and primary key

Based on our general understanding of how students register for courses
in college, the following are the functional dependencies:

1. `StudentID → FirstName, LastName`
   - A student ID uniquely determines the student's name.

2. `CourseID → CourseName, Credits, DepartmentID`
   - A course ID determines the course details.

3. `DepartmentID → DepartmentName, DepartmentHead, DeptPhone, DeptOffice`
   - A department ID determines the department details.

4. `StudentID, CourseID → Grade`
   - The combination of student and course determines the grade.


The **primary key** is the composite key **`(StudentID, CourseID)`**
since together they uniquely identify all values in each row.

## Second Normal Form (2NF)

A table is in Second Normal Form (2NF) if:

1. It is already in 1NF

2. There are no "Partial Functional Dependencies (pFD)" (see below)

### What is a "Partial Functional Dependency (pFD)" ?

A Partial Functional Dependency (pFD) is an FD for which the 
left hand side (LHS) is only part of the primary key (PK).

In our table, the primary key is the composite key `(StudentID, CourseID)`

Therefore the following functional dependencies 
are "partial functional dependencies" since the LHS of these FDs 
are only part the primary key.

* `StudentID → FirstName, LastName`

* `CourseID → CourseName, Credits, DepartmentID`

To achieve 2NF, we need to remove these partial dependencies by creating separate tables:

```{r}
# Create Student table (2NF)
student_2nf <- first_normal_form %>%
  select(StudentID, FirstName, LastName) %>%
  distinct()

# Create StudentCourse table (2NF)
student_course_2nf <- first_normal_form %>%
  select(StudentID, CourseID, Grade)

# Create Course table (2NF but not yet in 3NF)
course_2nf <- first_normal_form %>%
  select(CourseID, CourseName, Credits, DepartmentID, DepartmentName, DepartmentHead, DeptPhone, DeptOffice) %>%
  distinct()

# Display the 2NF tables
kable(student_2nf, caption = "student table", booktabs=TRUE)
kable(student_course_2nf, caption = "registration table", booktabs=TRUE)
kable(course_2nf, caption = "course table (2NF but not yet in 3NF)", booktabs=TRUE)
```

### General rules for how to convert a table to 2NF

1. For each partial functional dependency (pFD)
   create a new table that includes all of the columns from the pFD
   (choose a name for the new table)

2. The PK for the new table will be those columns from the left hand side (LHS) 
   of the pFD
   
3. Remove from the original table those columns that were on the right hand
   side (RHS) of the pFD
   
4. The columns from the LHS of the PFD will remain in the original table and
   become a foreign key (FK) to the new table.

## Third Normal Form (3NF)

A table is in Third Normal Form (3NF) if:

1. It is already in 2NF

2. It has no "Transitive Functional Dependencies (tFD)" (see next section)

### What is a "Transitive Functional Dependency (tFD)" ?

A transitive functional dependency occurs when there is an indirect relationship between attributes in a relation. Specifically, it happens when attribute A functionally determines attribute C through another attribute B.
Formally, if:

* A → B (A determines B) and
* B → C (B determines C)

Then we say that

* A transitively determines C  
* or in other words C is transitively dependent on A through B.

In our example since

* `CourseID → CourseName, Credits, DepartmentID`  
  i.e. CourseID determines DepartmentID

and 

* `DepartmentID → DepartmentName, DepartmentHead, DeptPhone, DeptOffice`

we can infer through the logic of [transitivity](https://byjus.com/maths/transitive-property/) 
that 

* `CourseID → DepartmentName, DepartmentHead, DeptPhone, DeptOffice`  
  **THIS IS A TRANSITIVE FUNCTIONAL DEPENDENCY**
  
  
Notice that the primary key for this version of the courses table is 
JUST `CourseID`. This is true since CourseID directly or through indirectly 
through transitivity determines all columns in the table. Specifically:

* `CourseId` directly determines `CourseName, Credits, DepartmentID`  
* `CourseId` indirectly (through DepartmentID) determines `DepartmentName, DepartmentHead, DeptPhone, DeptOffice`  

Therefore the Primary Key (PK) of the courses table is JUST `CourseId`
(not CourseId and DeptId).
Therefore there is no "Partial Functional Dependency" in this table
but there IS a "Transitive Functional Dependency" in this table.
 

### Convert the Courses table to be in 3NF

Again, looking at the Course table, we notice a transitive dependency:

- `CourseID → DepartmentID` (directly)
- `DepartmentID → DepartmentName, DepartmentHead, DeptPhone, DeptOffice` (directly)
- Therefore, `CourseID → DepartmentName, DepartmentHead, DeptPhone, DeptOffice` (transitively)

This is a classic transitive dependency where course details transitively determine department details through the DepartmentID. To achieve 3NF, we need to remove this transitive dependency from the course table.


```{r}
# Create Course table (3NF)
course_3nf <- course_2nf %>%
  select(CourseID, CourseName, Credits, DepartmentID) %>%
  distinct()

# Create Department table (3NF)
department_3nf <- course_2nf %>%
  select(DepartmentID, DepartmentName, DepartmentHead, DeptPhone, DeptOffice) %>%
  distinct()

# Display the 3NF tables
kable(course_3nf, caption = "Course Table (3NF)", booktabs=TRUE)
kable(department_3nf, caption = "Department Table (3NF)", booktabs=TRUE)
```

## The final design of all tables (i.e. the final table "schema")

The final 3NF versions of the tables are shown below:

```{r}
# Display the 3NF tables
kable(student_2nf, caption = "student table", booktabs=TRUE)
kable(student_course_2nf, caption = "student_course table", booktabs=TRUE)
kable(course_3nf, caption = "course table", booktabs=TRUE)
kable(department_3nf, caption = "department table", booktabs=TRUE)
```

### General rules for how to convert a table to 3NF

To convert a table to 3NF, given a table that contains the sets of columns A,B,C
(where each of A,B,C represents one or more columns) and
the following transitivity rules:

* A -> B

* B -> C

1. Create a new table (give it a name) that contains all columns from 
   B and C. 
   
2. The columns from B will become the primary key for the new table.

3. Remove from the original table the columns represented by C

4. The columns represented by B will remain in the original table and 
   will become a foreign key to the new table.

<!--
### Summary of Our Normalization Process

Let's visualize the relationships between our normalized tables:

```{r}
# Display all tables in their final form
cat("Final Normalized Tables:\n\n")

cat("StudentCourse Table (Primary Key: StudentID, CourseID):\n")
kable(student_course_2nf)
cat("\n\n")

cat("Student Table (Primary Key: StudentID):\n")
kable(student_2nf)
cat("\n\n")

cat("Course Table (Primary Key: CourseID):\n")
kable(course_3nf)
cat("\n\n")

cat("Department Table (Primary Key: DepartmentID):\n")
kable(department_3nf)
```

-->

<!--
```{r}
# Join all tables to reconstruct the original data
reconstructed_data <- student_course_2nf %>%
  left_join(student_2nf, by = "StudentID") %>%
  left_join(course_3nf, by = "CourseID") %>%
  left_join(department_3nf, by = "DepartmentID") %>%
  select(StudentID, FirstName, LastName, CourseID, CourseName, Credits, 
         DepartmentID, DepartmentName, DepartmentHead, DeptPhone, DeptOffice, Grade)

# Display the reconstructed data
kable(reconstructed_data, caption = "Reconstructed Data from Normalized Tables")
```
-->


<!--
### Benefits of Normalization

1. **Eliminating redundancy**: Notice how department information was repeated multiple times in our original table but appears only once in our final 3NF design.

2. **Preventing update anomalies**: If Dr. Johnson's phone number changes, we only need to update one row in the Department table, not multiple rows as in the original table.

3. **Improving data integrity**: Each entity (Student, Course, Department) is modeled in its own table with appropriate primary keys and relationships.

4. **Simplifying queries**: Complex data can be reconstructed using JOIN operations while maintaining a clean, normalized structure.

Each normal form builds upon the previous one, addressing specific types of data redundancy and potential anomalies. By following these normalization principles, you can create database designs that are more efficient, less prone to errors, and easier to maintain.
-->

<!--

# YR TODO - fix all of these examples

## OLD Normal Forms

### 1NF - First Normal Form

For a table to be in First Normal Form (1NF) it must satisfy the 
following requirements:

#### All attributes contain only atomic (indivisible) values

Each **cell** must contain a single, indivisible value — not a list, array, or multiple items.

The following Subjects column contains non-atomic values (a Violation of 1nf)

| StudentID | Subjects       |
|-----------|----------------|
| 001       | Math, Science  |
| 002       | History, Math  |
  
This is converted into 1NF by restructuring in the following way:
  
| StudentID | Subject  |
|-----------|----------|
| 001       | Math     |
| 001       | Science  |
| 002       | History  |
| 002       | Math     |

Each cell now has a single value; the table is in "1st normal form (1NF)".
  
#### There are no repeating groups or arrays

The table structure should not use multiple columns to represent values of the same type.

The following table violates 1NF since there is more than one Product column.

| OrderID | Product1 | Product2 | Product3 |
|---------|----------|----------|----------|
| 1001    | Apple    | Banana   | Orange   |

This is converted into 1NF by restructuring in the following way:

| OrderID | Product  |
|---------|----------|
| 1001    | Apple    |
| 1001    | Banana   |
| 1001    | Orange   |


1NF eliminates duplicate rows and ensures that each cell contains only a single value, not a collection of values.

### 2NF - Second Normal Form - no partial functional dependencies

As we saw above, the following table is in 1NF (atomic values, no repeating groups). 

| StudentID | FirstName | LastName | CourseID | CourseName     | Credits | Grade |
|-----------|-----------|----------|----------|----------------|---------|-------|
| 001       | Alice     | Smith    | C101     | Intro to Math  | 3       | A     |
| 002       | Bob       | Jones    | C101     | Intro to Math  | 3       | B     |
| 001       | Alice     | Smith    | C102     | English 101    | 4       | A-    |

However, let's remember the functional dependency rules. As noted above,
the functional dependencies are:

1. `StudentID → FirstName, LastName`  
   - A student ID uniquely determines the student's name.

2. `CourseID → CourseName, Credits`  
   - A course ID determines the course details.

3. `StudentID, CourseID → Grade`  
    
    or equivalently 
    
   `StudentID, CourseID → FirstName, LastName, CourseName, Credits, Grade`
   
   Which means that `StudentID, CourseID` is the primary key of the table.
  
Notice that 

* The functional dependency

  `StudentID → FirstName, LastName`  
  
  Is included as part of the functional dependency:
  
  `StudentID, CourseID → FirstName, LastName, CourseName, Credits, Grade`

  We say that `StudentID → FirstName, LastName`  is a ***partial*** **functional dependency** (pFD).
  
* Similarly `CourseID → CourseName, Credits` is also a 
  ***partial*** **functional dependency** (pFD).
  

To be in 2nd normal form, a table may not contain any ***partial*** functional dependencies.
Specifically:

**A table is in Second Normal Form if:**

- It is already in 1NF
- All non-key attributes are fully functionally dependent on the 
  ***entire*** primary key (not just part of it)


2NF eliminates partial dependencies by removing attributes that depend on 
only part of a composite primary key. This requires creating separate tables 
for those attributes and the part of the key they depend on.
To put a table into 2NF, you must split up the table into 2 or more tables
in the following way:

For each pFD:

1. Create a new table that contains all of the columns from the pFD.
   
   The columns from the left hand side (LHS) of the pFD become the 
   primary key of this new table.

2. Remove the columns that were on the "right hand side (RHS)" of the 
   pFD from the original table.
   
   The columns from the LHS of the pFD remain in the original table 
   and become a foreign key in the original table.
   



#### Example: 1NF but Not 2NF

The following table is in 1NF (atomic values, no repeating groups) but **not in 2NF** 
because some attributes depend only on part of a composite key.

| StudentID | FirstName | LastName | CourseID | CourseName     | Credits | Grade |
|-----------|-----------|----------|----------|----------------|---------|-------|
| 001       | Alice     | Smith    | C101     | Intro to Math  | 3       | A     |
| 002       | Bob       | Jones    | C101     | Intro to Math  | 3       | B     |
| 001       | Alice     | Smith    | C102     | English 101    | 4       | A-    |

- Composite primary key: `(StudentID, CourseID)`
- **Problem**: `CourseName` and `Credits` depend **only on `CourseID`**, 
  not on the whole key. We say that courseId -> CourseName, Credits is a
  **partial dependency** hence this table violates 2nf


To fix this we can separate this into three different tables:

**StudentCourse Table**

| StudentID | CourseID | Grade |
|-----------|----------|-------|
| 001       | C101     | A     |
| 002       | C101     | B     |
| 001       | C102     | A-    |

**Student Table**

| StudentID | FirstName | LastName |
|-----------|-----------|----------|
| 001       | Alice     | Smith    |
| 002       | Bob       | Jones    |

**Course Table**

| CourseID | CourseName     | Credits |
|----------|----------------|---------|
| C101     | Intro to Math  | 3       |
| C102     | English 101    | 4       |

Now, in each table,  
all non-key attributes depend on the **entire primary key**,  
meeting 2NF requirements.





### 3NF - Third Normal Form

A table is in Third Normal Form if:

- It is already in 2NF
- It has no transitive dependencies (non-key attributes depending on other non-key attributes)

3NF eliminates transitive dependencies by creating separate tables for attributes that depend on non-key attributes. This ensures that every non-key attribute depends directly on the primary key and not on another non-key attribute.

## Normalization Examples

### Example 1: Online Bookstore

#### Example 1 - Functional Dependencies

- BookID → Title, Author, AuthorEmail, Publisher, PublisherAddress, Category, CategoryDescription, Price
- Author → AuthorEmail
- Publisher → PublisherAddress
- Category → CategoryDescription

#### Unnormalized Data

```{r}
# Create a CSV file for the unnormalized books data
books_unnormalized <- data.frame(
  BookID = c("B001", "B002", "B003"),
  Title = c("Database Design", "SQL Basics", "Network Security"),
  Author = c("John Smith", "John Smith", "Mary Jones"),
  AuthorEmail = c("john@example.com", "john@example.com", "mary@example.com"),
  Publisher = c("TechPress", "TechPress", "SecureBooks"),
  PublisherAddress = c("123 Tech St, NY", "123 Tech St, NY", "456 Secure Ave, CA"),
  Category = c("Database", "Programming", "Security"),
  CategoryDescription = c("About database systems", "About programming", "About security systems"),
  Price = c(45.99, 39.99, 52.99)
)

# Save to CSV
write.csv(books_unnormalized, "books_unnormalized.csv", row.names = FALSE)

# Read from CSV to demonstrate
books_df <- read.csv("books_unnormalized.csv")
kable(books_df, caption = "Unnormalized Books Table")
```

#### Example 1 -  1NF

In this case, the data is already in 1NF as it has a primary key (BookID) and all values are atomic.

```{r}
# The 1NF table is the same as the unnormalized table for this example
books_1nf <- books_unnormalized
kable(books_1nf, caption = "Books Table in 1NF")
```

#### Example 1 - 2NF

To move to 2NF, we need to separate the data into multiple tables to eliminate partial dependencies.

```{r}
# Create the normalized tables for 2NF
books_2nf <- data.frame(
  BookID = c("B001", "B002", "B003"),
  Title = c("Database Design", "SQL Basics", "Network Security"),
  Author = c("John Smith", "John Smith", "Mary Jones"),
  Publisher = c("TechPress", "TechPress", "SecureBooks"),
  Category = c("Database", "Programming", "Security"),
  Price = c(45.99, 39.99, 52.99)
)

authors_2nf <- data.frame(
  Author = c("John Smith", "Mary Jones"),
  AuthorEmail = c("john@example.com", "mary@example.com")
)

publishers_2nf <- data.frame(
  Publisher = c("TechPress", "SecureBooks"),
  PublisherAddress = c("123 Tech St, NY", "456 Secure Ave, CA")
)

categories_2nf <- data.frame(
  Category = c("Database", "Programming", "Security"),
  CategoryDescription = c("About database systems", "About programming", "About security systems")
)

# Save to CSV
write.csv(books_2nf, "books_2nf.csv", row.names = FALSE)
write.csv(authors_2nf, "authors_2nf.csv", row.names = FALSE)
write.csv(publishers_2nf, "publishers_2nf.csv", row.names = FALSE)
write.csv(categories_2nf, "categories_2nf.csv", row.names = FALSE)

# Read from CSV
books_2nf_df <- read.csv("books_2nf.csv")
authors_2nf_df <- read.csv("authors_2nf.csv")
publishers_2nf_df <- read.csv("publishers_2nf.csv")
categories_2nf_df <- read.csv("categories_2nf.csv")

# Display tables
kable(books_2nf_df, caption = "Books Table in 2NF")
kable(authors_2nf_df, caption = "Authors Table in 2NF")
kable(publishers_2nf_df, caption = "Publishers Table in 2NF")
kable(categories_2nf_df, caption = "Categories Table in 2NF")
```

#### Example 1 - 3NF

For this example, the 2NF design is already in 3NF because there are no transitive dependencies.

```{r}
# Create SQLite database for the 3NF design
db <- dbConnect(SQLite(), ":memory:")

# Create tables
dbExecute(db, "CREATE TABLE Books (
  BookID TEXT PRIMARY KEY,
  Title TEXT,
  Author TEXT,
  Publisher TEXT,
  Category TEXT,
  Price REAL
)")

dbExecute(db, "CREATE TABLE Authors (
  Author TEXT PRIMARY KEY,
  AuthorEmail TEXT
)")

dbExecute(db, "CREATE TABLE Publishers (
  Publisher TEXT PRIMARY KEY,
  PublisherAddress TEXT
)")

dbExecute(db, "CREATE TABLE Categories (
  Category TEXT PRIMARY KEY,
  CategoryDescription TEXT
)")

# Insert data
dbWriteTable(db, "Books", books_2nf_df, append = TRUE)
dbWriteTable(db, "Authors", authors_2nf_df, append = TRUE)
dbWriteTable(db, "Publishers", publishers_2nf_df, append = TRUE)
dbWriteTable(db, "Categories", categories_2nf_df, append = TRUE)

# Query to join data from multiple tables
query <- "
SELECT b.BookID, b.Title, b.Author, a.AuthorEmail, b.Publisher, p.PublisherAddress, 
       b.Category, c.CategoryDescription, b.Price
FROM Books b
JOIN Authors a ON b.Author = a.Author
JOIN Publishers p ON b.Publisher = p.Publisher
JOIN Categories c ON b.Category = c.Category
"

# Execute the query
result <- dbGetQuery(db, query)
kable(result, caption = "Joined Data from 3NF Tables")

# Disconnect from database
dbDisconnect(db)
```

### Example 2: University Enrollment

#### Example 2 - Functional Dependencies

Let's identify the functional dependencies (FDs) in our data:
- StudentID → StudentName
- CourseID → CourseName, Credits, InstructorID, Room
- InstructorID → InstructorName, InstructorDept, DeptChairContactInfo
- StudentID, CourseID → Grade

**Unnormalized Data**

```{r}
# Create a CSV file for the unnormalized enrollments data
enrollments_unnormalized <- data.frame(
  StudentID = c("S101", "S102", "S101", "S103"),
  StudentName = c("Alice Brown", "Bob Green", "Alice Brown", "Carol White"),
  CourseID = c("C201", "C201", "C202", "C305"),
  CourseName = c("Database Systems", "Database Systems", "Web Programming", "Statistics"),
  InstructorID = c("I301", "I301", "I302", "I405"),
  InstructorName = c("Dr. Smith", "Dr. Smith", "Dr. Johnson", "Dr. Davis"),
  InstructorDept = c("Computer Science", "Computer Science", "Computer Science", "Mathematics"),
  DeptChairContactInfo = c("cs-chair@university.edu", "cs-chair@university.edu", "cs-chair@university.edu", "math-chair@university.edu"),
  Room = c("R105", "R105", "R107", "R201"),
  Credits = c(3, 3, 4, 3),
  Grade = c("A", "B", "B+", "A-")
)

# Save to CSV
write.csv(enrollments_unnormalized, "enrollments_unnormalized.csv", row.names = FALSE)

# Read from CSV
enrollments_df <- read.csv("enrollments_unnormalized.csv")
kable(enrollments_df, caption = "Unnormalized Enrollments Table")
```

#### Example 2 - 1NF

The data is already in 1NF as all values are atomic and there are no repeating groups.

#### Example 2 - 2NF

A table is in 2NF if it is in 1NF and no non-prime attribute (an attribute that is not part of any candidate key) is dependent on only a portion of a candidate key.

In our unnormalized table, the primary key is the composite key (StudentID, CourseID), since this combination uniquely identifies each row. Let's identify the partial dependencies:

1. StudentName depends only on StudentID (part of the primary key)
2. CourseName, Credits, InstructorID, and Room depend only on CourseID (part of the primary key)
3. InstructorName, InstructorDept, and DeptChairContactInfo depend only on InstructorID, which itself depends on CourseID

These are all partial dependencies because they depend on only part of the primary key (either StudentID or CourseID alone), not the entire key (StudentID, CourseID). To achieve 2NF, we need to eliminate these partial dependencies by creating separate tables.

```{r}
# Create the normalized tables for 2NF
students_2nf <- data.frame(
  StudentID = c("S101", "S102", "S103"),
  StudentName = c("Alice Brown", "Bob Green", "Carol White")
)

courses_2nf <- data.frame(
  CourseID = c("C201", "C202", "C305"),
  CourseName = c("Database Systems", "Web Programming", "Statistics"),
  Credits = c(3, 4, 3),
  InstructorID = c("I301", "I302", "I405"),
  Room = c("R105", "R107", "R201")
)

instructors_2nf <- data.frame(
  InstructorID = c("I301", "I302", "I405"),
  InstructorName = c("Dr. Smith", "Dr. Johnson", "Dr. Davis"),
  InstructorDept = c("Computer Science", "Computer Science", "Mathematics"),
  DeptChairContactInfo = c("cs-chair@university.edu", "cs-chair@university.edu", "math-chair@university.edu")
)

enrollment_2nf <- data.frame(
  StudentID = c("S101", "S102", "S101", "S103"),
  CourseID = c("C201", "C201", "C202", "C305"),
  Grade = c("A", "B", "B+", "A-")
)

# Save to CSV
write.csv(students_2nf, "students_2nf.csv", row.names = FALSE)
write.csv(courses_2nf, "courses_2nf.csv", row.names = FALSE)
write.csv(instructors_2nf, "instructors_2nf.csv", row.names = FALSE)
write.csv(enrollment_2nf, "enrollment_2nf.csv", row.names = FALSE)

# Read from CSV
students_2nf_df <- read.csv("students_2nf.csv")
courses_2nf_df <- read.csv("courses_2nf.csv")
instructors_2nf_df <- read.csv("instructors_2nf.csv")
enrollment_2nf_df <- read.csv("enrollment_2nf.csv")

# Display tables
kable(students_2nf_df, caption = "Students Table in 2NF")
kable(courses_2nf_df, caption = "Courses Table in 2NF")
kable(instructors_2nf_df, caption = "Instructors Table in 2NF")
kable(enrollment_2nf_df, caption = "Enrollment Table in 2NF")
```

Now each table has a simple primary key (not composite), and all attributes in each table are fully dependent on the primary key of that table. We've resolved the partial dependencies:
- Students table: StudentName fully depends on StudentID
- Courses table: CourseName, Credits, Room, and InstructorID fully depend on CourseID
- Instructors table: InstructorName, InstructorDept, and DeptChairContactInfo fully depend on InstructorID
- Enrollment table: Grade fully depends on the composite key (StudentID, CourseID)

#### Example 2 - 3NF

A table is in 3NF if it is in 2NF and no non-prime attribute (an attribute that is not part of any candidate key) is transitively dependent on the primary key.

A transitive dependency occurs when one non-key attribute depends on another non-key attribute, which in turn depends on the primary key. In our 2NF schema, we still have transitive dependencies in the Instructors table:

InstructorID → InstructorDept → DeptChairContactInfo

Here, DeptChairContactInfo doesn't directly depend on InstructorID. Instead, it depends on InstructorDept, which depends on InstructorID. This creates a transitive dependency.

Let's look at the data more closely:
- All instructors in the Computer Science department have the same chair contact (cs-chair@university.edu)
- All instructors in the Mathematics department have the same chair contact (math-chair@university.edu)

This indicates that DeptChairContactInfo is really a property of the department, not of the individual instructor. To eliminate this transitive dependency, we need to create a separate Departments table.

```{r}
# Create the normalized tables for 3NF 
# Create new Departments table to eliminate transitive dependency
departments_3nf <- data.frame(
  DeptName = c("Computer Science", "Mathematics"),
  DeptChairContactInfo = c("cs-chair@university.edu", "math-chair@university.edu")
)

# Modify Instructors table to remove the transitive dependency
instructors_3nf <- data.frame(
  InstructorID = c("I301", "I302", "I405"),
  InstructorName = c("Dr. Smith", "Dr. Johnson", "Dr. Davis"),
  InstructorDept = c("Computer Science", "Computer Science", "Mathematics")
)

# Other tables remain the same as in 2NF because they don't have transitive dependencies
students_3nf <- students_2nf
courses_3nf <- courses_2nf
enrollment_3nf <- enrollment_2nf

# Save to CSV
write.csv(departments_3nf, "departments_3nf.csv", row.names = FALSE)
write.csv(instructors_3nf, "instructors_3nf.csv", row.names = FALSE)

# Read from CSV
departments_3nf_df <- read.csv("departments_3nf.csv")
instructors_3nf_df <- read.csv("instructors_3nf.csv")

# Display tables
kable(departments_3nf_df, caption = "Departments Table in 3NF")
kable(instructors_3nf_df, caption = "Instructors Table in 3NF (Modified)")

# Create SQLite database
db <- dbConnect(SQLite(), ":memory:")

# Create tables
dbExecute(db, "CREATE TABLE Students (
  StudentID TEXT PRIMARY KEY,
  StudentName TEXT
)")

dbExecute(db, "CREATE TABLE Departments (
  DeptName TEXT PRIMARY KEY,
  DeptChairContactInfo TEXT
)")

dbExecute(db, "CREATE TABLE Instructors (
  InstructorID TEXT PRIMARY KEY,
  InstructorName TEXT,
  InstructorDept TEXT,
  FOREIGN KEY (InstructorDept) REFERENCES Departments(DeptName)
)")

dbExecute(db, "CREATE TABLE Courses (
  CourseID TEXT PRIMARY KEY,
  CourseName TEXT,
  Credits INTEGER,
  InstructorID TEXT,
  Room TEXT,
  FOREIGN KEY (InstructorID) REFERENCES Instructors(InstructorID)
)")

dbExecute(db, "CREATE TABLE Enrollment (
  StudentID TEXT,
  CourseID TEXT,
  Grade TEXT,
  PRIMARY KEY (StudentID, CourseID),
  FOREIGN KEY (StudentID) REFERENCES Students(StudentID),
  FOREIGN KEY (CourseID) REFERENCES Courses(CourseID)
)")

# Insert data
dbWriteTable(db, "Students", students_3nf, append = TRUE)
dbWriteTable(db, "Departments", departments_3nf, append = TRUE)
dbWriteTable(db, "Instructors", instructors_3nf, append = TRUE)
dbWriteTable(db, "Courses", courses_3nf, append = TRUE)
dbWriteTable(db, "Enrollment", enrollment_3nf, append = TRUE)

# Query to join data from multiple tables
query <- "
SELECT s.StudentID, s.StudentName, c.CourseID, c.CourseName, 
       i.InstructorID, i.InstructorName, i.InstructorDept, d.DeptChairContactInfo,
       c.Room, c.Credits, e.Grade
FROM Enrollment e
JOIN Students s ON e.StudentID = s.StudentID
JOIN Courses c ON e.CourseID = c.CourseID
JOIN Instructors i ON c.InstructorID = i.InstructorID
JOIN Departments d ON i.InstructorDept = d.DeptName
"

# Execute the query
result <- dbGetQuery(db, query)
kable(result, caption = "Joined Data from 3NF Tables")

# Disconnect from database
dbDisconnect(db)
```

With these changes, all tables are now in 3NF because:

1. They are in 2NF (all non-key attributes are fully functionally dependent on the primary key)

2. There are no transitive dependencies (no non-key attribute depends on another non-key attribute)

In this example, we see that:

- DeptChairContactInfo depends on DeptName (not on InstructorID directly)

- By separating this into a Departments table, we've eliminated the transitive dependency

- The Instructors table now references DeptName, which serves as the primary key in the Departments table

Note that we can still reconstruct the original data by joining these normalized tables, as demonstrated in the final query.


# YR TODO - fix this

### Example 2: University Enrollment

**Unnormalized Data**

```{r}
# Create a CSV file for the unnormalized enrollments data
enrollments_unnormalized <- data.frame(
  StudentID = c("S101", "S102", "S101", "S103"),
  StudentName = c("Alice Brown", "Bob Green", "Alice Brown", "Carol White"),
  CourseID = c("C201", "C201", "C202", "C305"),
  CourseName = c("Database Systems", "Database Systems", "Web Programming", "Statistics"),
  InstructorID = c("I301", "I301", "I302", "I405"),
  InstructorName = c("Dr. Smith", "Dr. Smith", "Dr. Johnson", "Dr. Davis"),
  InstructorDept = c("Computer Science", "Computer Science", "Computer Science", "Mathematics"),
  Room = c("R105", "R105", "R107", "R201"),
  Credits = c(3, 3, 4, 3),
  Grade = c("A", "B", "B+", "A-")
)

# Save to CSV
write.csv(enrollments_unnormalized, "enrollments_unnormalized.csv", row.names = FALSE)

# Read from CSV
enrollments_df <- read.csv("enrollments_unnormalized.csv")
kable(enrollments_df, caption = "Unnormalized Enrollments Table")
```

#### Example 2 - Functional Dependencies

Let's identify the functional dependencies (FDs) in our data:

- StudentID → StudentName
- CourseID → CourseName, Credits, InstructorID, Room
- InstructorID → InstructorName, InstructorDept
- StudentID, CourseID → Grade


#### Example 2 - 1NF

The data is already in 1NF as all values are atomic and there are no repeating groups.

#### Example 2 - 2NF

A table is in 2NF if it is in 1NF and no non-prime attribute (an attribute that is not part of any candidate key) is dependent on only a portion of a candidate key.

In our unnormalized table, the primary key is the composite key (StudentID, CourseID), since this combination uniquely identifies each row. Let's identify the partial dependencies:

- StudentID → StudentName

  StudentName depends only on StudentID (part of the primary key)
  
  
- CourseID → CourseName, Credits, InstructorID, Room

  CourseName, Credits, InstructorID, and Room depend only on CourseID (part of the primary key)

- InstructorID → InstructorName, InstructorDept

  InstructorName and InstructorDept depend only on InstructorID, which itself depends on CourseID

These are all partial dependencies because they depend on only part of the primary key (either StudentID or CourseID alone), not the entire key (StudentID, CourseID). To achieve 2NF, we need to eliminate these partial dependencies by creating separate tables.

```{r}
# Create the normalized tables for 2NF
students_2nf <- data.frame(
  StudentID = c("S101", "S102", "S103"),
  StudentName = c("Alice Brown", "Bob Green", "Carol White")
)

courses_2nf <- data.frame(
  CourseID = c("C201", "C202", "C305"),
  CourseName = c("Database Systems", "Web Programming", "Statistics"),
  Credits = c(3, 4, 3),
  InstructorID = c("I301", "I302", "I405"),
  Room = c("R105", "R107", "R201")
)

instructors_2nf <- data.frame(
  InstructorID = c("I301", "I302", "I405"),
  InstructorName = c("Dr. Smith", "Dr. Johnson", "Dr. Davis"),
  InstructorDept = c("Computer Science", "Computer Science", "Mathematics")
)

enrollment_2nf <- data.frame(
  StudentID = c("S101", "S102", "S101", "S103"),
  CourseID = c("C201", "C201", "C202", "C305"),
  Grade = c("A", "B", "B+", "A-")
)

# Save to CSV
write.csv(students_2nf, "students_2nf.csv", row.names = FALSE)
write.csv(courses_2nf, "courses_2nf.csv", row.names = FALSE)
write.csv(instructors_2nf, "instructors_2nf.csv", row.names = FALSE)
write.csv(enrollment_2nf, "enrollment_2nf.csv", row.names = FALSE)

# Read from CSV
students_2nf_df <- read.csv("students_2nf.csv")
courses_2nf_df <- read.csv("courses_2nf.csv")
instructors_2nf_df <- read.csv("instructors_2nf.csv")
enrollment_2nf_df <- read.csv("enrollment_2nf.csv")

# Display tables
kable(students_2nf_df, caption = "Students Table in 2NF")
kable(courses_2nf_df, caption = "Courses Table in 2NF")
kable(instructors_2nf_df, caption = "Instructors Table in 2NF")
kable(enrollment_2nf_df, caption = "Enrollment Table in 2NF")
```

Now each table has a simple primary key (not composite), and all attributes in each table are fully dependent on the primary key of that table. We've resolved the partial dependencies:

- Students table: StudentName fully depends on StudentID
- Courses table: CourseName, Credits, Room, and InstructorID fully depend on CourseID
- Instructors table: InstructorName and InstructorDept fully depend on InstructorID
- Enrollment table: Grade fully depends on the composite key (StudentID, CourseID)

#### Example 2 - 3NF

A table is in 3NF if it is in 2NF and no non-prime attribute (an attribute that is not part of any candidate key) is transitively dependent on the primary key.

A transitive dependency occurs when one non-key attribute depends on another non-key attribute, which in turn depends on the primary key. In our 2NF schema, we still have a transitive dependency in the Instructors table:

InstructorID → InstructorDept (InstructorDept depends on InstructorID)

But we can further normalize by recognizing that departments can exist independently of instructors, and multiple instructors can belong to the same department. This creates a transitive dependency:

InstructorID → DeptID → DeptName

To eliminate this transitive dependency, we need to create a separate Departments table and modify the Instructors table to reference DeptID instead of storing DeptName directly.

```{r}
# Create the normalized tables for 3NF 
# Create new Departments table to eliminate transitive dependency
departments_3nf <- data.frame(
  DeptID = c("CS", "MATH"),
  DeptName = c("Computer Science", "Mathematics")
)

# Modify Instructors table to reference DeptID instead of storing DeptName directly
instructors_3nf <- data.frame(
  InstructorID = c("I301", "I302", "I405"),
  InstructorName = c("Dr. Smith", "Dr. Johnson", "Dr. Davis"),
  DeptID = c("CS", "CS", "MATH")
)

# Other tables remain the same as in 2NF because they don't have transitive dependencies
students_3nf <- students_2nf
courses_3nf <- courses_2nf
enrollment_3nf <- enrollment_2nf

# Save to CSV
write.csv(departments_3nf, "departments_3nf.csv", row.names = FALSE)
write.csv(instructors_3nf, "instructors_3nf.csv", row.names = FALSE)

# Read from CSV
departments_3nf_df <- read.csv("departments_3nf.csv")
instructors_3nf_df <- read.csv("instructors_3nf.csv")

# Display tables
kable(departments_3nf_df, caption = "Departments Table in 3NF")
kable(instructors_3nf_df, caption = "Instructors Table in 3NF (Modified)")

# Create SQLite database
db <- dbConnect(SQLite(), ":memory:")

# Create tables
dbExecute(db, "CREATE TABLE Students (
  StudentID TEXT PRIMARY KEY,
  StudentName TEXT
)")

dbExecute(db, "CREATE TABLE Departments (
  DeptID TEXT PRIMARY KEY,
  DeptName TEXT
)")

dbExecute(db, "CREATE TABLE Instructors (
  InstructorID TEXT PRIMARY KEY,
  InstructorName TEXT,
  DeptID TEXT,
  FOREIGN KEY (DeptID) REFERENCES Departments(DeptID)
)")

dbExecute(db, "CREATE TABLE Courses (
  CourseID TEXT PRIMARY KEY,
  CourseName TEXT,
  Credits INTEGER,
  InstructorID TEXT,
  Room TEXT,
  FOREIGN KEY (InstructorID) REFERENCES Instructors(InstructorID)
)")

dbExecute(db, "CREATE TABLE Enrollment (
  StudentID TEXT,
  CourseID TEXT,
  Grade TEXT,
  PRIMARY KEY (StudentID, CourseID),
  FOREIGN KEY (StudentID) REFERENCES Students(StudentID),
  FOREIGN KEY (CourseID) REFERENCES Courses(CourseID)
)")

# Insert data
dbWriteTable(db, "Students", students_3nf, append = TRUE)
dbWriteTable(db, "Departments", departments_3nf, append = TRUE)
dbWriteTable(db, "Instructors", instructors_3nf, append = TRUE)
dbWriteTable(db, "Courses", courses_3nf, append = TRUE)
dbWriteTable(db, "Enrollment", enrollment_3nf, append = TRUE)

# Query to join data from multiple tables
query <- "
SELECT s.StudentID, s.StudentName, c.CourseID, c.CourseName, 
       i.InstructorID, i.InstructorName, d.DeptName, c.Room, c.Credits, e.Grade
FROM Enrollment e
JOIN Students s ON e.StudentID = s.StudentID
JOIN Courses c ON e.CourseID = c.CourseID
JOIN Instructors i ON c.InstructorID = i.InstructorID
JOIN Departments d ON i.DeptID = d.DeptID
"

# Execute the query
result <- dbGetQuery(db, query)
kable(result, caption = "Joined Data from 3NF Tables")

# Disconnect from database
dbDisconnect(db)
```

With these changes, all tables are now in 3NF because:
1. They are in 2NF (all non-key attributes are fully functionally dependent on the primary key)
2. There are no transitive dependencies (no non-key attribute depends on another non-key attribute)

Note that we can still reconstruct the original data by joining these normalized tables, as demonstrated in the final query.








# YR TODO - fix this also

### Example 2: University Enrollment

#### Example 2 - Functional Dependencies

- StudentID → StudentName
- CourseID → CourseName, Credits, InstructorID, Room
- InstructorID → InstructorName, InstructorDept
- StudentID, CourseID → Grade

**Unnormalized Data**

```{r}
# Create a CSV file for the unnormalized enrollments data
enrollments_unnormalized <- data.frame(
  StudentID = c("S101", "S102", "S101", "S103"),
  StudentName = c("Alice Brown", "Bob Green", "Alice Brown", "Carol White"),
  CourseID = c("C201", "C201", "C202", "C305"),
  CourseName = c("Database Systems", "Database Systems", "Web Programming", "Statistics"),
  InstructorID = c("I301", "I301", "I302", "I405"),
  InstructorName = c("Dr. Smith", "Dr. Smith", "Dr. Johnson", "Dr. Davis"),
  InstructorDept = c("Computer Science", "Computer Science", "Computer Science", "Mathematics"),
  Room = c("R105", "R105", "R107", "R201"),
  Credits = c(3, 3, 4, 3),
  Grade = c("A", "B", "B+", "A-")
)

# Save to CSV
write.csv(enrollments_unnormalized, "enrollments_unnormalized.csv", row.names = FALSE)

# Read from CSV
enrollments_df <- read.csv("enrollments_unnormalized.csv")
kable(enrollments_df, caption = "Unnormalized Enrollments Table")
```

#### Example 2 - 1NF

The data is already in 1NF as all values are atomic
and there are no repeating groups.

#### Example 2 - 2NF

To move to 2NF, we need to separate the data to eliminate partial dependencies.

```{r}
# Create the normalized tables for 2NF
students_2nf <- data.frame(
  StudentID = c("S101", "S102", "S103"),
  StudentName = c("Alice Brown", "Bob Green", "Carol White")
)

courses_2nf <- data.frame(
  CourseID = c("C201", "C202", "C305"),
  CourseName = c("Database Systems", "Web Programming", "Statistics"),
  Credits = c(3, 4, 3),
  InstructorID = c("I301", "I302", "I405"),
  Room = c("R105", "R107", "R201")
)

instructors_2nf <- data.frame(
  InstructorID = c("I301", "I302", "I405"),
  InstructorName = c("Dr. Smith", "Dr. Johnson", "Dr. Davis"),
  InstructorDept = c("Computer Science", "Computer Science", "Mathematics")
)

enrollment_2nf <- data.frame(
  StudentID = c("S101", "S102", "S101", "S103"),
  CourseID = c("C201", "C201", "C202", "C305"),
  Grade = c("A", "B", "B+", "A-")
)

# Save to CSV
write.csv(students_2nf, "students_2nf.csv", row.names = FALSE)
write.csv(courses_2nf, "courses_2nf.csv", row.names = FALSE)
write.csv(instructors_2nf, "instructors_2nf.csv", row.names = FALSE)
write.csv(enrollment_2nf, "enrollment_2nf.csv", row.names = FALSE)

# Read from CSV
students_2nf_df <- read.csv("students_2nf.csv")
courses_2nf_df <- read.csv("courses_2nf.csv")
instructors_2nf_df <- read.csv("instructors_2nf.csv")
enrollment_2nf_df <- read.csv("enrollment_2nf.csv")

# Display tables
kable(students_2nf_df, caption = "Students Table in 2NF")
kable(courses_2nf_df, caption = "Courses Table in 2NF")
kable(instructors_2nf_df, caption = "Instructors Table in 2NF")
kable(enrollment_2nf_df, caption = "Enrollment Table in 2NF")
```

#### Example 2 - 3NF

To move to 3NF, we need to eliminate transitive dependencies.

```{r}
# Create the normalized tables for 3NF (Only Courses table needs to be modified)
departments_3nf <- data.frame(
  DeptID = c("CS", "MATH"),
  DeptName = c("Computer Science", "Mathematics")
)

instructors_3nf <- data.frame(
  InstructorID = c("I301", "I302", "I405"),
  InstructorName = c("Dr. Smith", "Dr. Johnson", "Dr. Davis"),
  DeptID = c("CS", "CS", "MATH")
)

# Other tables remain the same as in 2NF
students_3nf <- students_2nf
courses_3nf <- courses_2nf
enrollment_3nf <- enrollment_2nf

# Save to CSV
write.csv(departments_3nf, "departments_3nf.csv", row.names = FALSE)
write.csv(instructors_3nf, "instructors_3nf.csv", row.names = FALSE)

# Read from CSV
departments_3nf_df <- read.csv("departments_3nf.csv")
instructors_3nf_df <- read.csv("instructors_3nf.csv")

# Display tables
kable(departments_3nf_df, caption = "Departments Table in 3NF")
kable(instructors_3nf_df, caption = "Instructors Table in 3NF (Modified)")

# Create SQLite database
db <- dbConnect(SQLite(), ":memory:")

# Create tables
dbExecute(db, "CREATE TABLE Students (
  StudentID TEXT PRIMARY KEY,
  StudentName TEXT
)")

dbExecute(db, "CREATE TABLE Departments (
  DeptID TEXT PRIMARY KEY,
  DeptName TEXT
)")

dbExecute(db, "CREATE TABLE Instructors (
  InstructorID TEXT PRIMARY KEY,
  InstructorName TEXT,
  DeptID TEXT,
  FOREIGN KEY (DeptID) REFERENCES Departments(DeptID)
)")

dbExecute(db, "CREATE TABLE Courses (
  CourseID TEXT PRIMARY KEY,
  CourseName TEXT,
  Credits INTEGER,
  InstructorID TEXT,
  Room TEXT,
  FOREIGN KEY (InstructorID) REFERENCES Instructors(InstructorID)
)")

dbExecute(db, "CREATE TABLE Enrollment (
  StudentID TEXT,
  CourseID TEXT,
  Grade TEXT,
  PRIMARY KEY (StudentID, CourseID),
  FOREIGN KEY (StudentID) REFERENCES Students(StudentID),
  FOREIGN KEY (CourseID) REFERENCES Courses(CourseID)
)")

# Insert data
dbWriteTable(db, "Students", students_3nf, append = TRUE)
dbWriteTable(db, "Departments", departments_3nf, append = TRUE)
dbWriteTable(db, "Instructors", instructors_3nf, append = TRUE)
dbWriteTable(db, "Courses", courses_3nf, append = TRUE)
dbWriteTable(db, "Enrollment", enrollment_3nf, append = TRUE)

# Query to join data from multiple tables
query <- "
SELECT s.StudentID, s.StudentName, c.CourseID, c.CourseName, 
       i.InstructorID, i.InstructorName, d.DeptName, c.Room, c.Credits, e.Grade
FROM Enrollment e
JOIN Students s ON e.StudentID = s.StudentID
JOIN Courses c ON e.CourseID = c.CourseID
JOIN Instructors i ON c.InstructorID = i.InstructorID
JOIN Departments d ON i.DeptID = d.DeptID
"

# Execute the query
result <- dbGetQuery(db, query)
kable(result, caption = "Joined Data from 3NF Tables")

# Disconnect from database
dbDisconnect(db)
```



### Example 3: Retail Store Inventory

#### Example 3 - Functional Dependencies

- ProductID → ProductName, CategoryID, SupplierID, UnitPrice
- CategoryID → CategoryName
- SupplierID → SupplierName, SupplierContact
- WarehouseID → WarehouseLoc
- ProductID, WarehouseID → Quantity

**Unnormalized Data**

```{r}
# Create a CSV file for the unnormalized inventory data
inventory_unnormalized <- data.frame(
  ProductID = c("P1001", "P1002", "P1003", "P1004"),
  ProductName = c("Laptop XS", "Mouse Pro", "Desk Chair", "Coffee Mug"),
  CategoryID = c("C01", "C01", "C02", "C03"),
  CategoryName = c("Electronics", "Electronics", "Furniture", "Kitchenware"),
  SupplierID = c("S01", "S01", "S02", "S03"),
  SupplierName = c("TechSupplies", "TechSupplies", "FurnStore", "HomeGoods"),
  SupplierContact = c("555-1234", "555-1234", "555-5678", "555-9012"),
  WarehouseID = c("W01", "W01", "W02", "W01"),
  WarehouseLoc = c("North", "North", "South", "North"),
  Quantity = c(25, 100, 15, 200),
  UnitPrice = c(899.99, 24.99, 149.99, 8.99)
)

# Save to CSV
write.csv(inventory_unnormalized, "inventory_unnormalized.csv", row.names = FALSE)

# Read from CSV
inventory_df <- read.csv("inventory_unnormalized.csv")
kable(inventory_df, caption = "Unnormalized Inventory Table")
```

#### Example 3 - 1NF

The data is already in 1NF as it has a primary key and all values are atomic.

```{r}
# The 1NF table is the same as the unnormalized table
inventory_1nf <- inventory_unnormalized
kable(inventory_1nf, caption = "Inventory Table in 1NF")
```

#### Example 3 - 2NF

To move to 2NF, we need to separate the data to eliminate partial dependencies.

```{r}
# Create the normalized tables for 2NF
products_2nf <- data.frame(
  ProductID = c("P1001", "P1002", "P1003", "P1004"),
  ProductName = c("Laptop XS", "Mouse Pro", "Desk Chair", "Coffee Mug"),
  CategoryID = c("C01", "C01", "C02", "C03"),
  SupplierID = c("S01", "S01", "S02", "S03"),
  UnitPrice = c(899.99, 24.99, 149.99, 8.99)
)

categories_2nf <- data.frame(
  CategoryID = c("C01", "C02", "C03"),
  CategoryName = c("Electronics", "Furniture", "Kitchenware")
)

suppliers_2nf <- data.frame(
  SupplierID = c("S01", "S02", "S03"),
  SupplierName = c("TechSupplies", "FurnStore", "HomeGoods"),
  SupplierContact = c("555-1234", "555-5678", "555-9012")
)

warehouses_2nf <- data.frame(
  WarehouseID = c("W01", "W02"),
  WarehouseLoc = c("North", "South")
)

inventory_items_2nf <- data.frame(
  ProductID = c("P1001", "P1002", "P1003", "P1004"),
  WarehouseID = c("W01", "W01", "W02", "W01"),
  Quantity = c(25, 100, 15, 200)
)

# Save to CSV
write.csv(products_2nf, "products_2nf.csv", row.names = FALSE)
write.csv(categories_2nf, "categories_2nf.csv", row.names = FALSE)
write.csv(suppliers_2nf, "suppliers_2nf.csv", row.names = FALSE)
write.csv(warehouses_2nf, "warehouses_2nf.csv", row.names = FALSE)
write.csv(inventory_items_2nf, "inventory_items_2nf.csv", row.names = FALSE)

# Read from CSV
products_2nf_df <- read.csv("products_2nf.csv")
categories_2nf_df <- read.csv("categories_2nf.csv")
suppliers_2nf_df <- read.csv("suppliers_2nf.csv")
warehouses_2nf_df <- read.csv("warehouses_2nf.csv")
inventory_items_2nf_df <- read.csv("inventory_items_2nf.csv")

# Display tables
kable(products_2nf_df, caption = "Products Table in 2NF")
kable(categories_2nf_df, caption = "Categories Table in 2NF")
kable(suppliers_2nf_df, caption = "Suppliers Table in 2NF")
kable(warehouses_2nf_df, caption = "Warehouses Table in 2NF")
kable(inventory_items_2nf_df, caption = "Inventory Items Table in 2NF")
```

#### Example 3 - 3NF

For this example, the 2NF design is already in 3NF because there are no transitive dependencies.

```{r}
# Create SQLite database
db <- dbConnect(SQLite(), ":memory:")

# Create tables
dbExecute(db, "CREATE TABLE Categories (
  CategoryID TEXT PRIMARY KEY,
  CategoryName TEXT
)")

dbExecute(db, "CREATE TABLE Suppliers (
  SupplierID TEXT PRIMARY KEY,
  SupplierName TEXT,
  SupplierContact TEXT
)")

dbExecute(db, "CREATE TABLE Products (
  ProductID TEXT PRIMARY KEY,
  ProductName TEXT,
  CategoryID TEXT,
  SupplierID TEXT,
  UnitPrice REAL,
  FOREIGN KEY (CategoryID) REFERENCES Categories(CategoryID),
  FOREIGN KEY (SupplierID) REFERENCES Suppliers(SupplierID)
)")

dbExecute(db, "CREATE TABLE Warehouses (
  WarehouseID TEXT PRIMARY KEY,
  WarehouseLoc TEXT
)")

dbExecute(db, "CREATE TABLE Inventory (
  ProductID TEXT,
  WarehouseID TEXT,
  Quantity INTEGER,
  PRIMARY KEY (ProductID, WarehouseID),
  FOREIGN KEY (ProductID) REFERENCES Products(ProductID),
  FOREIGN KEY (WarehouseID) REFERENCES Warehouses(WarehouseID)
)")

# Insert data
dbWriteTable(db, "Categories", categories_2nf_df, append = TRUE)
dbWriteTable(db, "Suppliers", suppliers_2nf_df, append = TRUE)
dbWriteTable(db, "Products", products_2nf_df, append = TRUE)
dbWriteTable(db, "Warehouses", warehouses_2nf_df, append = TRUE)
dbWriteTable(db, "Inventory", inventory_items_2nf_df, append = TRUE)

# Query to join data from multiple tables
query <- "
SELECT p.ProductID, p.ProductName, c.CategoryID, c.CategoryName, 
       s.SupplierID, s.SupplierName, s.SupplierContact, 
       w.WarehouseID, w.WarehouseLoc, i.Quantity, p.UnitPrice
FROM Products p
JOIN Categories c ON p.CategoryID = c.CategoryID
JOIN Suppliers s ON p.SupplierID = s.SupplierID
JOIN Inventory i ON p.ProductID = i.ProductID
JOIN Warehouses w ON i.WarehouseID = w.WarehouseID
"

# Execute the query
result <- dbGetQuery(db, query)
kable(result, caption = "Joined Data from 3NF Tables")

# Disconnect from database
dbDisconnect(db)
```

### Example 4: Medical Clinic

#### Example 4 - Functional Dependencies

- AppointmentID → PatientID, DoctorID, AppointmentDate, Status
- PatientID → PatientName, PatientDOB
- DoctorID → DoctorName, DoctorSpecialty, DeptID
- DeptID → DeptName, DeptLocation

**Unnormalized Data**

```{r}
# Create a CSV file for the unnormalized appointments data
appointments_unnormalized <- data.frame(
  AppointmentID = c("A1001", "A1002", "A1003", "A1004"),
  PatientID = c("P101", "P102", "P101", "P103"),
  PatientName = c("John Doe", "Jane Smith", "John Doe", "Sam Johnson"),
  PatientDOB = c("1985-03-12", "1990-07-22", "1985-03-12", "1978-11-05"),
  DoctorID = c("D201", "D202", "D203", "D201"),
  DoctorName = c("Dr. Wilson", "Dr. Brown", "Dr. Miller", "Dr. Wilson"),
  DoctorSpecialty = c("Cardiology", "Pediatrics", "Orthopedics", "Cardiology"),
  DeptID = c("DP01", "DP02", "DP03", "DP01"),
  DeptName = c("Cardiology", "Pediatrics", "Orthopedics", "Cardiology"),
  DeptLocation = c("Floor 3", "Floor 1", "Floor 2", "Floor 3"),
  AppointmentDate = c("2023-06-15", "2023-06-16", "2023-06-18", "2023-06-20"),
  Status = c("Completed", "Scheduled", "Cancelled", "Scheduled")
)

# Save to CSV
write.csv(appointments_unnormalized, "appointments_unnormalized.csv", row.names = FALSE)

# Read from CSV
appointments_df <- read.csv("appointments_unnormalized.csv")
kable(appointments_df, caption = "Unnormalized Appointments Table")
```

#### Example 4 - 1NF

The data is already in 1NF as it has a primary key and all values are atomic.

```{r}
# The 1NF table is the same as the unnormalized table
appointments_1nf <- appointments_unnormalized
kable(appointments_1nf, caption = "Appointments Table in 1NF")
```

#### Example 4 - 2NF

To move to 2NF, we need to separate the data to eliminate partial dependencies.

```{r}
# Create the normalized tables for 2NF
appointments_2nf <- data.frame(
  AppointmentID = c("A1001", "A1002", "A1003", "A1004"),
  PatientID = c("P101", "P102", "P101", "P103"),
  DoctorID = c("D201", "D202", "D203", "D201"),
  AppointmentDate = c("2023-06-15", "2023-06-16", "2023-06-18", "2023-06-20"),
  Status = c("Completed", "Scheduled", "Cancelled", "Scheduled")
)

patients_2nf <- data.frame(
  PatientID = c("P101", "P102", "P103"),
  PatientName = c("John Doe", "Jane Smith", "Sam Johnson"),
  PatientDOB = c("1985-03-12", "1990-07-22", "1978-11-05")
)

doctors_2nf <- data.frame(
  DoctorID = c("D201", "D202", "D203"),
  DoctorName = c("Dr. Wilson", "Dr. Brown", "Dr. Miller"),
  DoctorSpecialty = c("Cardiology", "Pediatrics", "Orthopedics"),
  DeptID = c("DP01", "DP02", "DP03")
)

departments_2nf <- data.frame(
  DeptID = c("DP01", "DP02", "DP03"),
  DeptName = c("Cardiology", "Pediatrics", "Orthopedics"),
  DeptLocation = c("Floor 3", "Floor 1", "Floor 2")
)

# Save to CSV
write.csv(appointments_2nf, "appointments_2nf.csv", row.names = FALSE)
write.csv(patients_2nf, "patients_2nf.csv", row.names = FALSE)
write.csv(doctors_2nf, "doctors_2nf.csv", row.names = FALSE)
write.csv(departments_2nf, "departments_2nf.csv", row.names = FALSE)

# Read from CSV
appointments_2nf_df <- read.csv("appointments_2nf.csv")
patients_2nf_df <- read.csv("patients_2nf.csv")
doctors_2nf_df <- read.csv("doctors_2nf.csv")
departments_2nf_df <- read.csv("departments_2nf.csv")

# Display tables
kable(appointments_2nf_df, caption = "Appointments Table in 2NF")
kable(patients_2nf_df, caption = "Patients Table in 2NF")
kable(doctors_2nf_df, caption = "Doctors Table in 2NF")
kable(departments_2nf_df, caption = "Departments Table in 2NF")
```

#### Example 4 - 3NF

For this example, the tables are already in 3NF because there are no transitive dependencies.

```{r}
# Create SQLite database
db <- dbConnect(SQLite(), ":memory:")

# Create tables
dbExecute(db, "CREATE TABLE Departments (
  DeptID TEXT PRIMARY KEY,
  DeptName TEXT,
  DeptLocation TEXT
)")

dbExecute(db, "CREATE TABLE Doctors (
  DoctorID TEXT PRIMARY KEY,
  DoctorName TEXT,
  DoctorSpecialty TEXT,
  DeptID TEXT,
  FOREIGN KEY (DeptID) REFERENCES Departments(DeptID)
)")

dbExecute(db, "CREATE TABLE Patients (
  PatientID TEXT PRIMARY KEY,
  PatientName TEXT,
  PatientDOB TEXT
)")

dbExecute(db, "CREATE TABLE Appointments (
  AppointmentID TEXT PRIMARY KEY,
  PatientID TEXT,
  DoctorID TEXT,
  AppointmentDate TEXT,
  Status TEXT,
  FOREIGN KEY (PatientID) REFERENCES Patients(PatientID),
  FOREIGN KEY (DoctorID) REFERENCES Doctors(DoctorID)
)")

# Insert data
dbWriteTable(db, "Departments", departments_2nf_df, append = TRUE)
dbWriteTable(db, "Doctors", doctors_2nf_df, append = TRUE)
dbWriteTable(db, "Patients", patients_2nf_df, append = TRUE)
dbWriteTable(db, "Appointments", appointments_2nf_df, append = TRUE)

# Query to join data from multiple tables
query <- "
SELECT a.AppointmentID, a.AppointmentDate, a.Status,
       p.PatientID, p.PatientName, p.PatientDOB,
       d.DoctorID, d.DoctorName, d.DoctorSpecialty,
       dp.DeptID, dp.DeptName, dp.DeptLocation
FROM Appointments a
JOIN Patients p ON a.PatientID = p.PatientID
JOIN Doctors d ON a.DoctorID = d.DoctorID
JOIN Departments dp ON d.DeptID = dp.DeptID"


# Execute the query
result <- dbGetQuery(db, query)
kable(result, caption = "Joined Data from 3NF Tables")

# Disconnect from database
dbDisconnect(db)
```

### Example 5: Hotel Reservations

#### Example 5 - Functional Dependencies

- ReservationID → GuestID, RoomID, CheckInDate, CheckOutDate, PaymentID
- GuestID → GuestName, GuestEmail, GuestPhone
- RoomID → RoomType, RoomRate
- PaymentID → PaymentType, PaymentAmount

#### Example 5 - Unnormalized Data

```{r}
# Create a CSV file for the unnormalized reservations data
reservations_unnormalized <- data.frame(
  ReservationID = c("R001", "R002", "R003", "R004"),
  GuestID = c("G101", "G102", "G101", "G103"),
  GuestName = c("Mark Adams", "Susan Lee", "Mark Adams", "Tom Wilson"),
  GuestEmail = c("mark@example.com", "susan@example.com", "mark@example.com", "tom@example.com"),
  GuestPhone = c("555-1111", "555-2222", "555-1111", "555-3333"),
  RoomID = c("RM101", "RM102", "RM201", "RM103"),
  RoomType = c("Deluxe", "Standard", "Suite", "Standard"),
  RoomRate = c(199.99, 149.99, 299.99, 149.99),
  CheckInDate = c("2023-07-10", "2023-07-12", "2023-08-01", "2023-07-15"),
  CheckOutDate = c("2023-07-15", "2023-07-14", "2023-08-05", "2023-07-20"),
  PaymentID = c("P001", "P002", "P003", "P004"),
  PaymentType = c("Credit Card", "PayPal", "Credit Card", "Cash"),
  PaymentAmount = c(999.95, 299.98, 1199.96, 749.95)
)

# Save to CSV
write.csv(reservations_unnormalized, "reservations_unnormalized.csv", row.names = FALSE)

# Read from CSV
reservations_df <- read.csv("reservations_unnormalized.csv")
kable(reservations_df, caption = "Unnormalized Reservations Table")
```

#### Example 5 - 1NF

The data is already in 1NF as it has a primary key and all values are atomic.

```{r}
# The 1NF table is the same as the unnormalized table
reservations_1nf <- reservations_unnormalized
kable(reservations_1nf, caption = "Reservations Table in 1NF")
```

#### Example 5 - 2NF

To move to 2NF, we need to separate the data to eliminate partial dependencies.

```{r}
# Create the normalized tables for 2NF
reservations_2nf <- data.frame(
  ReservationID = c("R001", "R002", "R003", "R004"),
  GuestID = c("G101", "G102", "G101", "G103"),
  RoomID = c("RM101", "RM102", "RM201", "RM103"),
  CheckInDate = c("2023-07-10", "2023-07-12", "2023-08-01", "2023-07-15"),
  CheckOutDate = c("2023-07-15", "2023-07-14", "2023-08-05", "2023-07-20"),
  PaymentID = c("P001", "P002", "P003", "P004")
)

guests_2nf <- data.frame(
  GuestID = c("G101", "G102", "G103"),
  GuestName = c("Mark Adams", "Susan Lee", "Tom Wilson"),
  GuestEmail = c("mark@example.com", "susan@example.com", "tom@example.com"),
  GuestPhone = c("555-1111", "555-2222", "555-3333")
)

rooms_2nf <- data.frame(
  RoomID = c("RM101", "RM102", "RM201", "RM103"),
  RoomType = c("Deluxe", "Standard", "Suite", "Standard"),
  RoomRate = c(199.99, 149.99, 299.99, 149.99)
)

payments_2nf <- data.frame(
  PaymentID = c("P001", "P002", "P003", "P004"),
  PaymentType = c("Credit Card", "PayPal", "Credit Card", "Cash"),
  PaymentAmount = c(999.95, 299.98, 1199.96, 749.95)
)

# Save to CSV
write.csv(reservations_2nf, "reservations_2nf.csv", row.names = FALSE)
write.csv(guests_2nf, "guests_2nf.csv", row.names = FALSE)
write.csv(rooms_2nf, "rooms_2nf.csv", row.names = FALSE)
write.csv(payments_2nf, "payments_2nf.csv", row.names = FALSE)

# Read from CSV
reservations_2nf_df <- read.csv("reservations_2nf.csv")
guests_2nf_df <- read.csv("guests_2nf.csv")
rooms_2nf_df <- read.csv("rooms_2nf.csv")
payments_2nf_df <- read.csv("payments_2nf.csv")

# Display tables
kable(reservations_2nf_df, caption = "Reservations Table in 2NF")
kable(guests_2nf_df, caption = "Guests Table in 2NF")
kable(rooms_2nf_df, caption = "Rooms Table in 2NF")
kable(payments_2nf_df, caption = "Payments Table in 2NF")
```

#### Example 5 - 3NF

For this example, the 2NF design is already in 3NF because there are no transitive dependencies.

```{r}
# Create SQLite database
db <- dbConnect(SQLite(), ":memory:")

# Create tables
dbExecute(db, "CREATE TABLE Guests (
  GuestID TEXT PRIMARY KEY,
  GuestName TEXT,
  GuestEmail TEXT,
  GuestPhone TEXT
)")

dbExecute(db, "CREATE TABLE Rooms (
  RoomID TEXT PRIMARY KEY,
  RoomType TEXT,
  RoomRate REAL
)")

dbExecute(db, "CREATE TABLE Payments (
  PaymentID TEXT PRIMARY KEY,
  PaymentType TEXT,
  PaymentAmount REAL
)")

dbExecute(db, "CREATE TABLE Reservations (
  ReservationID TEXT PRIMARY KEY,
  GuestID TEXT,
  RoomID TEXT,
  CheckInDate TEXT,
  CheckOutDate TEXT,
  PaymentID TEXT,
  FOREIGN KEY (GuestID) REFERENCES Guests(GuestID),
  FOREIGN KEY (RoomID) REFERENCES Rooms(RoomID),
  FOREIGN KEY (PaymentID) REFERENCES Payments(PaymentID)
)")

# Insert data
dbWriteTable(db, "Guests", guests_2nf_df, append = TRUE)
dbWriteTable(db, "Rooms", rooms_2nf_df, append = TRUE)
dbWriteTable(db, "Payments", payments_2nf_df, append = TRUE)
dbWriteTable(db, "Reservations", reservations_2nf_df, append = TRUE)

# Query to join data from multiple tables
query <- "
SELECT r.ReservationID, r.CheckInDate, r.CheckOutDate,
       g.GuestID, g.GuestName, g.GuestEmail, g.GuestPhone,
       rm.RoomID, rm.RoomType, rm.RoomRate,
       p.PaymentID, p.PaymentType, p.PaymentAmount
FROM Reservations r
JOIN Guests g ON r.GuestID = g.GuestID
JOIN Rooms rm ON r.RoomID = rm.RoomID
JOIN Payments p ON r.PaymentID = p.PaymentID
"

# Execute the query
result <- dbGetQuery(db, query)
kable(result, caption = "Joined Data from 3NF Tables")

# Disconnect from database
dbDisconnect(db)
```

-->